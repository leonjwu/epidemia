
#' Helper for constructing an object of class 'epiobs'
#'
#' Defines a model for an observation vector. These observations
#' are taken to be a function of the latent infections in the poulation.
#' Examples include daily death or hospitalisation rates. For more details on
#' the model assumptions please refer to the online vignettes.
#'
#' @param formula A formula defining the model for the observations.
#' @param family A string representing the error distribution for the model.
#'  Can be "poisson", "neg_binom", "quasi_poisson", "normal" or "log_normal".
#' @param link A string representing the link function used to transform the
#'  covariates. The linear predictor constructed from the covariates is
#' transformed by the inverse link function, then multiplied by the weighted
#' previous infections. This quantity represents the mean of the response
#' distribution.
#' @param i2o A probability vector with the following interpretation.
#' Conditional on an observation "event" (i.e. a single death or
#' hospitalisation etc.), the nth element represents the probability that the
#' individual was infected exactly n days prior to this.
#' @param center If \code{TRUE} then the covariates are centered to
#'  have mean zero. All of the priors are then interpreted as
#'  priors on the centered covariates. Defaults to \code{FALSE}.
#' @param prior Same as in \code{\link[rstanarm]{stan_glm}}. **Note:**
#'  If \code{autoscale=TRUE} in the call to the prior distribution
#'  then automatic rescaling of the prior may take place.
#' @param prior_intercept Same as in \code{\link[rstanarm]{stan_glm}}. Prior
#'  for the regression intercept, if one has been specified.
#' @param prior_aux Specify the prior distribution for the auxiliary parameter
#'  if it exists. Only used if family is negative binomial (reciprocal 
#'  dispersion), quasi poisson (dispersion), normal (standard deviation) or 
#'  log normal (sigma parameter). See \code{\link[rstanarm]{stan_glm}}
#'  for more details.

#' @param ... Additional arguments for \code{\link[stats]{model.frame}}
#' @export
epiobs <- function(formula,
                   family = "neg_binom",
                   link = "logit",
                   i2o,
                   center = FALSE,
                   prior = rstanarm::normal(scale = .1),
                   prior_intercept = rstanarm::normal(scale = .1),
                   prior_aux = rstanarm::exponential(autoscale = TRUE),
                   ...) {
  call <- match.call(expand.dots = TRUE)
  formula <- check_obs_formula(formula)

  ok_families <- c("poisson", "neg_binom", "quasi_poisson", "normal", "log_normal")
  if (!(family %in% ok_families)) {
    stop("'family' must be one of ", paste(ok_families, collapse= ", "),
      call. = FALSE
    )
  }

  ok_links <- c("logit", "probit", "cauchit", "cloglog", "identity")
  if (!(link %in% ok_links)) {
    stop("'link' must be one of ", paste(ok_links, collapse=", "),
      call. = FALSE
    )
  }

  # i2o <- check_sv(i2o, name = "i2o") no longer required to be simplex
  i2o <- check_v(i2o, name = "i2o")
  if (sum(i2o) != 1) {
    warning("'i2o' does not sum to 1
     - check that this is intentional")
  }

  # only supported prior family is normal. (will change in future)
  ok_dists <- c("normal")
  if (!(prior$dist %in% ok_dists)) {
    stop("'prior' must be a call to rstanarm::normal",
      call. = FALSE
    )
  }

  if (attr(terms(formula), "intercept")) {
    if (!(prior_intercept$dist %in% ok_dists)) {
      stop("'prior_intercept' must be a call to rstanarm::normal",
        call. = FALSE
      )
    }
  } else {
    prior_intercept <- NULL
  }

  if (family != "poisson") {
    ok_aux_dists <- c("normal", "t", "cauchy", "exponential")
    if (!(prior_aux$dist %in% ok_aux_dists)) {
      stop("'prior_aux' must be one of ", paste(ok_aux_dists, collapse=", "),
        call. = FALSE
      )
    }
  } else {
    prior_aux <- NULL
  }


  out <- loo::nlist(
    call,
    formula,
    family,
    link,
    i2o,
    i2otype = "density",
    center,
    prior,
    prior_intercept,
    prior_aux,
    mfargs <- list(...)
  )
  class(out) <- "epiobs"
  return(out)
}

# This is a constructor for an internal class which is essentially the same
# as epiobs, however it constructs and stores the model matrix associated with
# the model, along with some other objects
#
# @templateVar epiobsArg object
# @template args-epiobs-object
# @param data The dataframe from which to construct the model matrix
epiobs_ <- function(object, data) {
  if (!inherits(object, "epiobs")) {
    stop("Bug found. Argument 'object' should have class 'epiobs'")
  }

  formula <- formula(object)
  args <- object$mfargs

  # deal with NAs before passing to parse_mm
  na_action <- args[["na.action"]]
  vars <- all_vars_obs(formula)

  data <- data[, vars]
  data <-
    if (is.null(na_action)) {
      na.omit(data)
    } else {
      na_action(data)
    }
  args <- c(args, list(
    formula = update(formula,
      paste0(.get_obs(formula), "~.")),
    data = data
  ))
  out <- c(object, do.call(parse_mm, args))

  obs <- data[, .get_obs(formula)]
  if (!is.numeric(obs)) {
    stop(paste0("response ", .get_obs(formula), " not numeric"),
    call. = FALSE)
  }

  out <- c(out, list(
    obs = obs,
    gr = droplevels(as.factor(data[, .get_group(formula)])),
    time = data[, .get_time(formula)]
  ))

  class(out) <- "epiobs_"
  return(out)
}

